#include "core/polynomial.h"
#include "core/de_casteljau.h"

/**
 * @file polynomial.cpp
 * @brief Implementation of the Polynomial class
 */

#include <algorithm>
#include <iostream>
#include <stdexcept>

#ifdef ENABLE_HIGH_PRECISION
#include "hp/polynomial_hp.h"
#include "hp/precision_conversion.h"
#endif

namespace {

// Compute strides for a tensor-product layout where the last dimension
// varies fastest.
void compute_strides(const std::vector<unsigned int>& degrees,
                     std::vector<std::size_t>& strides)
{
    const std::size_t dim = degrees.size();
    strides.assign(dim, 0u);

    std::size_t s = 1u;
    for (std::size_t k = dim; k-- > 0;) {
        strides[k] = s;
        s *= static_cast<std::size_t>(degrees[k] + 1u);
    }
}

// Flatten a multi-index using precomputed strides.
std::size_t flatten_index(const std::vector<unsigned int>& multi_index,
                          const std::vector<std::size_t>& strides)
{
    std::size_t idx = 0u;
    const std::size_t dim = multi_index.size();
    for (std::size_t k = 0; k < dim; ++k) {
        idx += static_cast<std::size_t>(multi_index[k]) * strides[k];
    }
    return idx;
}

// Increment a multi-index over all dimensions except the given axis.
// Returns false when all combinations have been exhausted.
bool increment_multi_except_axis(std::vector<unsigned int>& index,
                                 const std::vector<unsigned int>& degrees,
                                 std::size_t axis)
{
    const std::size_t dim = degrees.size();

    for (std::size_t d = dim; d-- > 0;) {
        if (d == axis) {
            continue;
        }
        if (index[d] < degrees[d]) {
            ++index[d];
            // Reset all dimensions greater than d (except axis) to zero.
            for (std::size_t e = d + 1; e < dim; ++e) {
                if (e == axis) {
                    continue;
                }
                index[e] = 0u;
            }
            return true;
        }
    }

    return false;
}

// Increment a multi-index over all dimensions.
// Returns false when all combinations have been exhausted.
bool increment_multi_index(std::vector<unsigned int>& index,
                           const std::vector<unsigned int>& degrees)
{
    const std::size_t dim = degrees.size();

    for (std::size_t d = dim; d-- > 0;) {
        if (index[d] < degrees[d]) {
            ++index[d];
            // Reset all dimensions greater than d to zero.
            for (std::size_t e = d + 1; e < dim; ++e) {
                index[e] = 0u;
            }
            return true;
        }
    }

    return false;
}

// Convert 1D power-basis coefficients to Bernstein coefficients using
// an iterative scheme that avoids explicit binomial coefficients.
// Based on the identity
//   b_k = sum_{i=0}^k a_i * C(k,i) / C(n,i),  0 <= k <= n,
// but the ratios C(k,i)/C(n,i) are generated by a stable downward
// recurrence in k for each fixed i.
void power_to_bernstein_1d(unsigned int degree,
                           const std::vector<double>& power_coeffs_1d,
                           std::vector<double>& bernstein_coeffs_1d)
{
    const std::size_t len = static_cast<std::size_t>(degree + 1u);
    bernstein_coeffs_1d.assign(len, 0.0);

    if (len == 0u) {
        return;
    }

    const int n = static_cast<int>(degree);

    // Accumulate contributions from each power-basis coefficient a_i.
    for (int i = 0; i <= n; ++i) {
        const double a_i = power_coeffs_1d[static_cast<std::size_t>(i)];

        // For fixed i, start from r_{n,i} = C(n,i)/C(n,i) = 1 and
        // move downward in k using
        //   r_{k,i} = r_{k+1,i} * (k + 1 - i) / (k + 1).
        double r = 1.0;

        // Contribution to k = n.
        bernstein_coeffs_1d[static_cast<std::size_t>(n)] += a_i * r;

        // Contributions to k = n-1, ..., i.
        for (int k = n - 1; k >= i; --k) {
            r *= static_cast<double>(k + 1 - i) / static_cast<double>(k + 1);
            bernstein_coeffs_1d[static_cast<std::size_t>(k)] += a_i * r;
        }
    }
}

// Evaluate 1D polynomial in power basis using Horner's method
// p(x) = a_0 + a_1*x + a_2*x^2 + ... + a_n*x^n
// Horner's form: p(x) = a_0 + x*(a_1 + x*(a_2 + ... + x*a_n))
double horner_eval_1d(const std::vector<double>& power_coeffs_1d, double x)
{
    if (power_coeffs_1d.empty()) {
        return 0.0;
    }

    // Start from highest degree coefficient
    const int n = static_cast<int>(power_coeffs_1d.size()) - 1;
    double result = power_coeffs_1d[n];

    // Work backwards through coefficients
    for (int i = n - 1; i >= 0; --i) {
        result = result * x + power_coeffs_1d[i];
    }

    return result;
}

// Evaluate tensor-product polynomial in power basis
// For multivariate case, evaluate dimension by dimension
double horner_eval_tensor(const std::vector<unsigned int>& degrees,
                          const std::vector<double>& power_coeffs,
                          const std::vector<double>& parameters)
{
    const std::size_t dim = degrees.size();

    // Univariate case: directly use Horner's method
    if (dim == 1u && parameters.size() == 1u) {
        return horner_eval_1d(power_coeffs, parameters[0]);
    }

    // Multivariate case: evaluate dimension by dimension
    // Similar to De Casteljau tensor product evaluation
    if (dim == 2u && parameters.size() == 2u) {
        const std::size_t nx = static_cast<std::size_t>(degrees[0] + 1u);
        const std::size_t ny = static_cast<std::size_t>(degrees[1] + 1u);

        const double x = parameters[0];
        const double y = parameters[1];

        // First evaluate along the second dimension (y) for each fixed x index
        std::vector<double> row_values(nx, 0.0);

        for (std::size_t ix = 0; ix < nx; ++ix) {
            const std::size_t offset = ix * ny;
            std::vector<double> row(power_coeffs.begin() + static_cast<std::ptrdiff_t>(offset),
                                    power_coeffs.begin() + static_cast<std::ptrdiff_t>(offset + ny));
            row_values[ix] = horner_eval_1d(row, y);
        }

        // Then evaluate the resulting 1D polynomial in x
        return horner_eval_1d(row_values, x);
    }

    // Higher-dimensional tensor-product evaluation not implemented yet
    // Fall back to 0 (should not happen in practice)
    return 0.0;
}

} // anonymous namespace

namespace polynomial_solver {

Polynomial::Polynomial()
    : dimension_(0u)
    , primary_rep_(PolynomialRepresentation::BERNSTEIN)
    , bernstein_valid_(false)
    , power_valid_(false)
{
}

Polynomial::Polynomial(const std::vector<unsigned int>& degrees,
                       const std::vector<double>& bernstein_coeffs)
    : dimension_(degrees.size())
    , primary_rep_(PolynomialRepresentation::BERNSTEIN)
    , bernstein_valid_(true)
    , power_valid_(false)
{
    // NOTE: We do NOT raise degree from 0 to 1 here.
    // Degree 0 polynomials (constants) are mathematically valid.
    // The graphControlPoints() method will handle degree-0 case specially
    // by returning 2 duplicate points for visualization purposes.

    degrees_ = degrees;
    bernstein_coeffs_ = bernstein_coeffs;
}

Polynomial::~Polynomial() {
    // No special cleanup required.
}

Polynomial Polynomial::fromBernstein(const std::vector<unsigned int>& degrees,
                                     const std::vector<double>& bernstein_coeffs)
{
    // TODO: Add validation if needed.
    return Polynomial(degrees, bernstein_coeffs);
}

Polynomial Polynomial::fromPower(const std::vector<unsigned int>& degrees,
                                 const std::vector<double>& power_coeffs)
{
    // NEW DESIGN: Store power coefficients as primary, Bernstein computed lazily
    const std::size_t dim = degrees.size();

    // Compute expected number of coefficients for original degrees.
    std::size_t count = 1u;
    for (std::size_t i = 0; i < degrees.size(); ++i) {
        count *= static_cast<std::size_t>(degrees[i] + 1u);
    }

    if (count == 0u) {
        Polynomial result;
        result.dimension_ = dim;
        result.degrees_ = degrees;
        result.primary_rep_ = PolynomialRepresentation::POWER;
        result.power_valid_ = true;
        result.bernstein_valid_ = false;
        return result;
    }

    // Copy and resize input coefficients as needed.
    std::vector<double> coeffs = power_coeffs;
    if (coeffs.size() < count) {
        coeffs.resize(count, 0.0);
    } else if (coeffs.size() > count) {
        coeffs.resize(count);
    }

    // NOTE: We do NOT raise degree from 0 to 1 here.
    // Degree 0 polynomials (constants) are mathematically valid.
    // The graphControlPoints() method will handle degree-0 case specially
    // by returning 2 duplicate points for visualization purposes.

    // Create polynomial with power coefficients as primary
    Polynomial result;
    result.dimension_ = dim;
    result.degrees_ = degrees;
    result.power_coeffs_ = coeffs;
    result.primary_rep_ = PolynomialRepresentation::POWER;
    result.power_valid_ = true;
    result.bernstein_valid_ = false;  // Will be computed lazily when needed

    return result;
}



std::size_t Polynomial::dimension() const {
    return dimension_;
}

const std::vector<unsigned int>& Polynomial::degrees() const {
    return degrees_;
}

std::size_t Polynomial::coefficientCount() const {
    std::size_t count = 1u;
    for (std::size_t i = 0; i < degrees_.size(); ++i) {
        count *= static_cast<std::size_t>(degrees_[i] + 1u);
    }
    return count;
}

const std::vector<double>& Polynomial::bernsteinCoefficients() const {
    if (!bernstein_valid_) {
        std::cerr << "\n========================================\n";
        std::cerr << "ERROR: Implicit Power->Bernstein conversion detected!\n";
        std::cerr << "========================================\n";
        std::cerr << "Polynomial::bernsteinCoefficients() called on polynomial with invalid Bernstein representation.\n";
        std::cerr << "This triggers implicit conversion which may introduce errors.\n";
        std::cerr << "\nTo fix this:\n";
        std::cerr << "1. Call ensureBernsteinPrimary() explicitly before accessing Bernstein coefficients\n";
        std::cerr << "2. Or use power-basis methods if working with power representation\n";
        std::cerr << "\nCurrent state:\n";
        std::cerr << "  Primary representation: " << (primary_rep_ == PolynomialRepresentation::POWER ? "POWER" : "BERNSTEIN") << "\n";
        std::cerr << "  Bernstein valid: " << (bernstein_valid_ ? "true" : "false") << "\n";
        std::cerr << "  Power valid: " << (power_valid_ ? "true" : "false") << "\n";
        std::cerr << "========================================\n\n";
        std::abort();
    }
    return bernstein_coeffs_;
}

const std::vector<double>& Polynomial::powerCoefficients() const {
    if (!power_valid_) {
        std::cerr << "\n========================================\n";
        std::cerr << "ERROR: Implicit Bernstein->Power conversion detected!\n";
        std::cerr << "========================================\n";
        std::cerr << "Polynomial::powerCoefficients() called on polynomial with invalid Power representation.\n";
        std::cerr << "This triggers implicit conversion which may introduce errors.\n";
        std::cerr << "\nTo fix this:\n";
        std::cerr << "1. Call ensurePowerPrimary() explicitly before accessing Power coefficients\n";
        std::cerr << "2. Or use Bernstein-basis methods if working with Bernstein representation\n";
        std::cerr << "\nCurrent state:\n";
        std::cerr << "  Primary representation: " << (primary_rep_ == PolynomialRepresentation::POWER ? "POWER" : "BERNSTEIN") << "\n";
        std::cerr << "  Bernstein valid: " << (bernstein_valid_ ? "true" : "false") << "\n";
        std::cerr << "  Power valid: " << (power_valid_ ? "true" : "false") << "\n";
        std::cerr << "========================================\n\n";
        std::abort();
    }
    return power_coeffs_;
}

PolynomialRepresentation Polynomial::primaryRepresentation() const {
    return primary_rep_;
}

bool Polynomial::hasPowerCoefficients() const {
    return power_valid_;
}

bool Polynomial::hasBernsteinCoefficients() const {
    return bernstein_valid_;
}

void Polynomial::ensureBernsteinPrimary() {
    if (primary_rep_ == PolynomialRepresentation::BERNSTEIN) {
        // Already Bernstein primary, nothing to do
        return;
    }

    // Currently power is primary, need to switch to Bernstein
    // First ensure Bernstein coefficients are computed
    if (!bernstein_valid_) {
        convertPowerToBernstein();
    }

    // Now switch primary representation
    // Power coefficients remain valid (cached as secondary)
    primary_rep_ = PolynomialRepresentation::BERNSTEIN;
}

void Polynomial::ensurePowerPrimary() {
    if (primary_rep_ == PolynomialRepresentation::POWER) {
        // Already power primary, nothing to do
        return;
    }

    // Currently Bernstein is primary, need to switch to power
    // First ensure power coefficients are computed
    if (!power_valid_) {
        convertBernsteinToPower();
    }

    // Now switch primary representation
    // Bernstein coefficients remain valid (cached as secondary)
    primary_rep_ = PolynomialRepresentation::POWER;
}

double Polynomial::evaluate(const std::vector<double>& parameters) const {
    // Choose evaluation method based on PRIMARY representation to avoid conversion errors
    // Primary representation is the original, accurate one

    if (primary_rep_ == PolynomialRepresentation::POWER) {
        // Primary is power: use Horner's method (no conversion, most accurate)
        if (!power_valid_) {
            // Should never happen - primary should always be valid
            std::cerr << "\nERROR: Primary representation (POWER) is not valid!\n";
            std::abort();
        }
        return horner_eval_tensor(degrees_, power_coeffs_, parameters);
    } else {
        // Primary is Bernstein: use De Casteljau (no conversion, most accurate)
        if (!bernstein_valid_) {
            // Should never happen - primary should always be valid
            std::cerr << "\nERROR: Primary representation (BERNSTEIN) is not valid!\n";
            std::abort();
        }
        return DeCasteljau::evaluateTensorProduct(degrees_, bernstein_coeffs_, parameters);
    }
}

double Polynomial::evaluate(double t) const {
    // Convenience overload for the univariate case.
    std::vector<double> params(1u, t);
    return evaluate(params);
}

Polynomial Polynomial::restrictedToInterval(std::size_t axis, double a, double b) const {
    // Restriction requires Bernstein coefficients (uses De Casteljau subdivision)
    // Ensure Bernstein coefficients are available
    if (!bernstein_valid_) {
        // Need to convert - this should only happen once per polynomial
        // The solver calls ensureBernsteinPrimary() on the root node, so this
        // conversion should be cached for all subsequent restrictions
        const_cast<Polynomial*>(this)->convertPowerToBernstein();
    }

    const std::size_t dim = degrees_.size();
    if (axis >= dim) {
        // Invalid axis: return a copy of the original polynomial.
        return Polynomial(degrees_, bernstein_coeffs_);
    }

    // Clamp a and b to [0,1].
    if (a < 0.0) {
        a = 0.0;
    }
    if (b > 1.0) {
        b = 1.0;
    }

    if (!(a >= 0.0 && b <= 1.0 && a < b)) {
        // Degenerate interval: return a copy.
        return Polynomial(degrees_, bernstein_coeffs_);
    }

    const unsigned int deg_axis = degrees_[axis];
    const std::size_t len_axis = static_cast<std::size_t>(deg_axis + 1u);

    if (len_axis <= 1u) {
        // Constant along this axis.
        return Polynomial(degrees_, bernstein_coeffs_);
    }

    // Precompute strides for tensor layout (last dimension fastest).
    std::vector<std::size_t> strides;
    compute_strides(degrees_, strides);

    std::vector<double> new_coeffs(bernstein_coeffs_.size(), 0.0);

    std::vector<unsigned int> multi_index(dim, 0u);
    std::vector<double> line(len_axis);
    std::vector<double> left;
    std::vector<double> right;

    // Iterate over all 1D slices along the given axis.
    std::fill(multi_index.begin(), multi_index.end(), 0u);
    bool first = true;
    while (first || increment_multi_except_axis(multi_index, degrees_, axis)) {
        first = false;

        // Gather coefficients along the current axis-line.
        for (std::size_t k = 0; k < len_axis; ++k) {
            multi_index[axis] = static_cast<unsigned int>(k);
            const std::size_t idx = flatten_index(multi_index, strides);
            line[k] = bernstein_coeffs_[idx];
        }

        // Restrict this 1D Bernstein polynomial to [a,b].
        std::vector<double> segment = line;

        if (a > 0.0) {
            DeCasteljau::subdivide1D(segment, a, left, right);
            segment = right; // [a,1]
        }

        const double denom = 1.0 - a;
        const double t_rel = (denom > 0.0) ? (b - a) / denom : 0.0;
        DeCasteljau::subdivide1D(segment, t_rel, left, right);

        const std::vector<double>& ab_coeffs = left; // represents [a,b]

        // Scatter the restricted coefficients back into the tensor.
        for (std::size_t k = 0; k < len_axis; ++k) {
            multi_index[axis] = static_cast<unsigned int>(k);
            const std::size_t idx = flatten_index(multi_index, strides);
            new_coeffs[idx] = ab_coeffs[k];
        }
    }

    return Polynomial(degrees_, new_coeffs);
}

std::size_t Polynomial::flattenIndex(const std::vector<unsigned int>& multi_index) const {
    std::size_t idx = 0u;
    std::size_t stride = 1u;
    const std::size_t dim = degrees_.size();

    // Last dimension varies fastest.
    for (std::size_t d = dim; d-- > 0;) {
        idx += static_cast<std::size_t>(multi_index[d]) * stride;
        stride *= static_cast<std::size_t>(degrees_[d] + 1u);
    }

    return idx;
}

void Polynomial::graphControlPoints(std::vector<double>& control_points) const {
    // Graph control points require Bernstein coefficients
    // Ensure Bernstein representation is available
    if (!bernstein_valid_) {
        // Need to convert - this should only happen once per polynomial
        const_cast<Polynomial*>(this)->convertPowerToBernstein();
    }

    const std::size_t dim = dimension_;

    // Check if any dimension has degree 0 (constant polynomial)
    // For visualization, we need at least 2 points per dimension
    // So we'll duplicate points along degree-0 dimensions
    std::vector<unsigned int> visual_degrees = degrees_;
    for (std::size_t i = 0; i < dim; ++i) {
        if (visual_degrees[i] == 0u) {
            visual_degrees[i] = 1u;  // Raise to degree 1 for visualization only
        }
    }

    // Compute visual coefficient count (for output)
    std::size_t visual_count = 1u;
    for (std::size_t i = 0; i < dim; ++i) {
        visual_count *= static_cast<std::size_t>(visual_degrees[i] + 1u);
    }

    const std::size_t stride = dim + 1u;
    control_points.assign(visual_count * stride, 0.0);

    if (visual_count == 0u) {
        return;
    }

    std::vector<unsigned int> visual_multi(dim, 0u);
    std::vector<unsigned int> actual_multi(dim, 0u);

    for (std::size_t visual_idx = 0; visual_idx < visual_count; ++visual_idx) {
        const std::size_t base = visual_idx * stride;

        // Map visual multi-index to actual multi-index
        // For degree-0 dimensions, both indices 0 and 1 map to actual index 0
        for (std::size_t j = 0; j < dim; ++j) {
            if (degrees_[j] == 0u) {
                actual_multi[j] = 0u;  // Always use index 0 for degree-0 dimensions
            } else {
                actual_multi[j] = visual_multi[j];
            }
        }

        // Compute actual linear index
        std::size_t actual_idx = 0;
        std::size_t actual_stride = 1;
        for (std::size_t d = dim; d-- > 0;) {
            actual_idx += actual_multi[d] * actual_stride;
            actual_stride *= (degrees_[d] + 1u);
        }

        // First dim coordinates: normalized parameter position (using visual degrees).
        for (std::size_t j = 0; j < dim; ++j) {
            double coord = 0.0;
            if (visual_degrees[j] > 0u) {
                coord = static_cast<double>(visual_multi[j]) /
                        static_cast<double>(visual_degrees[j]);
            }
            control_points[base + j] = coord;
        }

        // Last coordinate: function value (Bernstein coefficient from actual index).
        control_points[base + dim] = bernstein_coeffs_[actual_idx];

        // Increment visual multi-index with last dimension fastest.
        if (dim > 0u) {
            for (std::size_t d = dim; d-- > 0;) {
                if (visual_multi[d] < visual_degrees[d]) {
                    ++visual_multi[d];
                    for (std::size_t e = d + 1; e < dim; ++e) {
                        visual_multi[e] = 0u;
                    }
                    break;
                }
            }
        }
    }
}

void Polynomial::convertPowerToBernstein() const {
    // When high precision is enabled, use HP conversion for better accuracy
    // This gives ~256x better precision than direct double conversion
#ifdef ENABLE_HIGH_PRECISION
    const std::size_t dim = dimension_;

    if (dim == 0u) {
        bernstein_coeffs_ = power_coeffs_;
        bernstein_valid_ = true;
        return;
    }

    // Convert power coefficients to high precision
    std::vector<mpreal> power_hp;
    power_hp.reserve(power_coeffs_.size());
    for (double c : power_coeffs_) {
        power_hp.push_back(toHighPrecision(c));
    }

    // Create HP polynomial from power basis (stores power as primary)
    PolynomialHP poly_hp = fromPowerHP(degrees_, power_hp);

    // EXPLICITLY convert to Bernstein (required to avoid implicit conversion error)
    poly_hp.convertPowerToBernstein();

    // Get Bernstein coefficients (now valid, no conversion needed)
    const std::vector<mpreal>& bernstein_hp = poly_hp.bernsteinCoefficients();

    // Convert back to double
    bernstein_coeffs_.clear();
    bernstein_coeffs_.reserve(bernstein_hp.size());
    for (const mpreal& c : bernstein_hp) {
        bernstein_coeffs_.push_back(toDouble(c));
    }

    bernstein_valid_ = true;
#else
    // Fallback to double-precision conversion when HP not available
    const std::size_t dim = dimension_;

    if (dim == 0u) {
        bernstein_coeffs_ = power_coeffs_;
        bernstein_valid_ = true;
        return;
    }

    // Compute coefficient count
    std::size_t count = coefficientCount();

    // Copy power coefficients to working array
    std::vector<double> coeffs = power_coeffs_;

    // Precompute strides for the tensor layout (last dimension fastest)
    std::vector<std::size_t> strides;
    compute_strides(degrees_, strides);

    // Transform along each dimension separately from power basis to Bernstein
    std::vector<unsigned int> multi_index(dim, 0u);

    for (std::size_t axis = 0; axis < dim; ++axis) {
        const unsigned int deg_axis = degrees_[axis];
        const std::size_t len_axis = static_cast<std::size_t>(deg_axis + 1u);

        if (len_axis <= 1u) {
            continue; // nothing to do along this dimension
        }

        std::vector<double> line_in(len_axis);
        std::vector<double> line_out;

        std::fill(multi_index.begin(), multi_index.end(), 0u);
        bool first = true;

        while (first || increment_multi_except_axis(multi_index, degrees_, axis)) {
            first = false;

            // Gather a 1D slice along the current axis
            for (std::size_t k = 0; k < len_axis; ++k) {
                multi_index[axis] = static_cast<unsigned int>(k);
                const std::size_t idx = flatten_index(multi_index, strides);
                line_in[k] = coeffs[idx];
            }

            // Convert this slice from power basis to Bernstein basis
            power_to_bernstein_1d(deg_axis, line_in, line_out);

            // Scatter converted coefficients back
            for (std::size_t k = 0; k < len_axis; ++k) {
                multi_index[axis] = static_cast<unsigned int>(k);
                const std::size_t idx = flatten_index(multi_index, strides);
                coeffs[idx] = line_out[k];
            }
        }
    }

    bernstein_coeffs_ = coeffs;
    bernstein_valid_ = true;
#endif
}

void Polynomial::convertBernsteinToPower() const {
    // TODO: Implement Bernstein-to-power conversion
    // For now, just copy (this is a placeholder - will implement properly)
    // This conversion is rarely needed in practice
    power_coeffs_ = bernstein_coeffs_;
    power_valid_ = true;
}

//=============================================================================
// Polynomial Arithmetic
//=============================================================================

Polynomial Polynomial::operator*(const Polynomial& other) const {
    if (dimension_ != other.dimension_) {
        throw std::invalid_argument("Polynomial multiplication requires same dimension");
    }

    if (dimension_ == 0) {
        return Polynomial();
    }

    // Get power coefficients of both polynomials
    const std::vector<double>& a = powerCoefficients();
    const std::vector<double>& b = other.powerCoefficients();

    // Result degrees = sum of degrees
    std::vector<unsigned int> result_degrees(dimension_);
    for (std::size_t i = 0; i < dimension_; ++i) {
        result_degrees[i] = degrees_[i] + other.degrees_[i];
    }

    // Compute result size and allocate
    std::size_t result_size = 1;
    for (std::size_t i = 0; i < dimension_; ++i) {
        result_size *= (result_degrees[i] + 1);
    }
    std::vector<double> result_coeffs(result_size, 0.0);

    // Compute strides for all arrays
    std::vector<std::size_t> strides_a, strides_b, strides_result;
    compute_strides(degrees_, strides_a);
    compute_strides(other.degrees_, strides_b);
    compute_strides(result_degrees, strides_result);

    // Iterate over all multi-indices of a
    std::vector<unsigned int> idx_a(dimension_, 0);
    do {
        std::size_t flat_a = flatten_index(idx_a, strides_a);
        double coeff_a = a[flat_a];
        if (coeff_a == 0.0) continue;

        // Iterate over all multi-indices of b
        std::vector<unsigned int> idx_b(dimension_, 0);
        do {
            std::size_t flat_b = flatten_index(idx_b, strides_b);
            double coeff_b = b[flat_b];
            if (coeff_b == 0.0) continue;

            // Result index = idx_a + idx_b
            std::vector<unsigned int> idx_result(dimension_);
            for (std::size_t i = 0; i < dimension_; ++i) {
                idx_result[i] = idx_a[i] + idx_b[i];
            }
            std::size_t flat_result = flatten_index(idx_result, strides_result);
            result_coeffs[flat_result] += coeff_a * coeff_b;

        } while (increment_multi_index(idx_b, other.degrees_));
    } while (increment_multi_index(idx_a, degrees_));

    return Polynomial::fromPower(result_degrees, result_coeffs);
}

Polynomial Polynomial::operator-(const Polynomial& other) const {
    if (dimension_ != other.dimension_) {
        throw std::invalid_argument("Polynomial subtraction requires same dimension");
    }

    if (dimension_ == 0) {
        return Polynomial();
    }

    // Get power coefficients of both polynomials
    const std::vector<double>& a = powerCoefficients();
    const std::vector<double>& b = other.powerCoefficients();

    // Result degrees = max of degrees
    std::vector<unsigned int> result_degrees(dimension_);
    for (std::size_t i = 0; i < dimension_; ++i) {
        result_degrees[i] = std::max(degrees_[i], other.degrees_[i]);
    }

    // Compute result size and allocate
    std::size_t result_size = 1;
    for (std::size_t i = 0; i < dimension_; ++i) {
        result_size *= (result_degrees[i] + 1);
    }
    std::vector<double> result_coeffs(result_size, 0.0);

    // Compute strides
    std::vector<std::size_t> strides_a, strides_b, strides_result;
    compute_strides(degrees_, strides_a);
    compute_strides(other.degrees_, strides_b);
    compute_strides(result_degrees, strides_result);

    // Add coefficients from a
    std::vector<unsigned int> idx(dimension_, 0);
    do {
        std::size_t flat_a = flatten_index(idx, strides_a);
        std::size_t flat_result = flatten_index(idx, strides_result);
        result_coeffs[flat_result] += a[flat_a];
    } while (increment_multi_index(idx, degrees_));

    // Subtract coefficients from b
    idx.assign(dimension_, 0);
    do {
        std::size_t flat_b = flatten_index(idx, strides_b);
        std::size_t flat_result = flatten_index(idx, strides_result);
        result_coeffs[flat_result] -= b[flat_b];
    } while (increment_multi_index(idx, other.degrees_));

    return Polynomial::fromPower(result_degrees, result_coeffs);
}

Polynomial Polynomial::operator+(const Polynomial& other) const {
    if (dimension_ != other.dimension_) {
        throw std::invalid_argument("Polynomial addition requires same dimension");
    }

    if (dimension_ == 0) {
        return Polynomial();
    }

    // Get power coefficients of both polynomials
    const std::vector<double>& a = powerCoefficients();
    const std::vector<double>& b = other.powerCoefficients();

    // Result degrees = max of degrees
    std::vector<unsigned int> result_degrees(dimension_);
    for (std::size_t i = 0; i < dimension_; ++i) {
        result_degrees[i] = std::max(degrees_[i], other.degrees_[i]);
    }

    // Compute result size and allocate
    std::size_t result_size = 1;
    for (std::size_t i = 0; i < dimension_; ++i) {
        result_size *= (result_degrees[i] + 1);
    }
    std::vector<double> result_coeffs(result_size, 0.0);

    // Compute strides
    std::vector<std::size_t> strides_a, strides_b, strides_result;
    compute_strides(degrees_, strides_a);
    compute_strides(other.degrees_, strides_b);
    compute_strides(result_degrees, strides_result);

    // Add coefficients from a
    std::vector<unsigned int> idx(dimension_, 0);
    do {
        std::size_t flat_a = flatten_index(idx, strides_a);
        std::size_t flat_result = flatten_index(idx, strides_result);
        result_coeffs[flat_result] += a[flat_a];
    } while (increment_multi_index(idx, degrees_));

    // Add coefficients from b
    idx.assign(dimension_, 0);
    do {
        std::size_t flat_b = flatten_index(idx, strides_b);
        std::size_t flat_result = flatten_index(idx, strides_result);
        result_coeffs[flat_result] += b[flat_b];
    } while (increment_multi_index(idx, other.degrees_));

    return Polynomial::fromPower(result_degrees, result_coeffs);
}

Polynomial Polynomial::operator*(double scalar) const {
    const std::vector<double>& coeffs = powerCoefficients();
    std::vector<double> result_coeffs(coeffs.size());
    for (std::size_t i = 0; i < coeffs.size(); ++i) {
        result_coeffs[i] = coeffs[i] * scalar;
    }
    return Polynomial::fromPower(degrees_, result_coeffs);
}

Polynomial Polynomial::operator-() const {
    return (*this) * (-1.0);
}

} // namespace polynomial_solver
