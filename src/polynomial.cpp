#include "polynomial.h"
#include "de_casteljau.h"

/**
 * @file polynomial.cpp
 * @brief Implementation of the Polynomial class
 */

#include <algorithm>
#include <iostream>

namespace {

// Compute strides for a tensor-product layout where the last dimension
// varies fastest.
void compute_strides(const std::vector<unsigned int>& degrees,
                     std::vector<std::size_t>& strides)
{
    const std::size_t dim = degrees.size();
    strides.assign(dim, 0u);

    std::size_t s = 1u;
    for (std::size_t k = dim; k-- > 0;) {
        strides[k] = s;
        s *= static_cast<std::size_t>(degrees[k] + 1u);
    }
}

// Flatten a multi-index using precomputed strides.
std::size_t flatten_index(const std::vector<unsigned int>& multi_index,
                          const std::vector<std::size_t>& strides)
{
    std::size_t idx = 0u;
    const std::size_t dim = multi_index.size();
    for (std::size_t k = 0; k < dim; ++k) {
        idx += static_cast<std::size_t>(multi_index[k]) * strides[k];
    }
    return idx;
}

// Increment a multi-index over all dimensions except the given axis.
// Returns false when all combinations have been exhausted.
bool increment_multi_except_axis(std::vector<unsigned int>& index,
                                 const std::vector<unsigned int>& degrees,
                                 std::size_t axis)
{
    const std::size_t dim = degrees.size();

    for (std::size_t d = dim; d-- > 0;) {
        if (d == axis) {
            continue;
        }
        if (index[d] < degrees[d]) {
            ++index[d];
            // Reset all dimensions greater than d (except axis) to zero.
            for (std::size_t e = d + 1; e < dim; ++e) {
                if (e == axis) {
                    continue;
                }
                index[e] = 0u;
            }
            return true;
        }
    }

    return false;
}

// Convert 1D power-basis coefficients to Bernstein coefficients using
// an iterative scheme that avoids explicit binomial coefficients.
// Based on the identity
//   b_k = sum_{i=0}^k a_i * C(k,i) / C(n,i),  0 <= k <= n,
// but the ratios C(k,i)/C(n,i) are generated by a stable downward
// recurrence in k for each fixed i.
void power_to_bernstein_1d(unsigned int degree,
                           const std::vector<double>& power_coeffs_1d,
                           std::vector<double>& bernstein_coeffs_1d)
{
    const std::size_t len = static_cast<std::size_t>(degree + 1u);
    bernstein_coeffs_1d.assign(len, 0.0);

    if (len == 0u) {
        return;
    }

    const int n = static_cast<int>(degree);

    // Accumulate contributions from each power-basis coefficient a_i.
    for (int i = 0; i <= n; ++i) {
        const double a_i = power_coeffs_1d[static_cast<std::size_t>(i)];

        // For fixed i, start from r_{n,i} = C(n,i)/C(n,i) = 1 and
        // move downward in k using
        //   r_{k,i} = r_{k+1,i} * (k + 1 - i) / (k + 1).
        double r = 1.0;

        // Contribution to k = n.
        bernstein_coeffs_1d[static_cast<std::size_t>(n)] += a_i * r;

        // Contributions to k = n-1, ..., i.
        for (int k = n - 1; k >= i; --k) {
            r *= static_cast<double>(k + 1 - i) / static_cast<double>(k + 1);
            bernstein_coeffs_1d[static_cast<std::size_t>(k)] += a_i * r;
        }
    }
}

} // anonymous namespace

namespace polynomial_solver {

Polynomial::Polynomial()
    : dimension_(0u)
{
}

Polynomial::Polynomial(const std::vector<unsigned int>& degrees,
                       const std::vector<double>& bernstein_coeffs)
    : dimension_(degrees.size()),
      degrees_(degrees),
      bernstein_coeffs_(bernstein_coeffs)
{
    // TODO: Optionally validate that bernstein_coeffs_.size()
    // matches coefficientCount().
}

Polynomial::~Polynomial() {
    // No special cleanup required.
}

Polynomial Polynomial::fromBernstein(const std::vector<unsigned int>& degrees,
                                     const std::vector<double>& bernstein_coeffs)
{
    // TODO: Add validation if needed.
    return Polynomial(degrees, bernstein_coeffs);
}

Polynomial Polynomial::fromPower(const std::vector<unsigned int>& degrees,
                                 const std::vector<double>& power_coeffs)
{
    const std::size_t dim = degrees.size();

    // Compute expected number of coefficients for original degrees.
    std::size_t count = 1u;
    for (std::size_t i = 0; i < degrees.size(); ++i) {
        count *= static_cast<std::size_t>(degrees[i] + 1u);
    }

    if (count == 0u) {
        return Polynomial(degrees, std::vector<double>());
    }

    // Copy and resize input coefficients as needed.
    std::vector<double> coeffs = power_coeffs;
    if (coeffs.size() < count) {
        coeffs.resize(count, 0.0);
    } else if (coeffs.size() > count) {
        coeffs.resize(count);
    }

    if (dim == 0u) {
        return Polynomial(degrees, coeffs);
    }

    // Precompute strides for the tensor layout (last dimension fastest).
    std::vector<std::size_t> strides;
    compute_strides(degrees, strides);

    // Transform along each dimension separately from power basis to Bernstein.
    std::vector<unsigned int> multi_index(dim, 0u);

    bool debug = false; // (dim == 2 && degrees[0] == 2 && degrees[1] == 1);

    for (std::size_t axis = 0; axis < dim; ++axis) {
        const unsigned int deg_axis = degrees[axis];
        const std::size_t len_axis = static_cast<std::size_t>(deg_axis + 1u);

        if (len_axis <= 1u) {
            continue; // nothing to do along this dimension
        }

        std::vector<double> line_in(len_axis);
        std::vector<double> line_out;

        std::fill(multi_index.begin(), multi_index.end(), 0u);
        bool first = true;

        while (first || increment_multi_except_axis(multi_index, degrees, axis)) {
            first = false;

            // Gather a 1D slice along the current axis.
            for (std::size_t k = 0; k < len_axis; ++k) {
                multi_index[axis] = static_cast<unsigned int>(k);
                const std::size_t idx = flatten_index(multi_index, strides);
                line_in[k] = coeffs[idx];
            }

            if (debug) {
                std::cout << "DEBUG: axis=" << axis << ", multi_index=(";
                for (std::size_t d = 0; d < dim; ++d) {
                    if (d > 0) std::cout << ",";
                    if (d == axis) std::cout << "*";
                    else std::cout << multi_index[d];
                }
                std::cout << "), line_in=[";
                for (std::size_t k = 0; k < len_axis; ++k) {
                    if (k > 0) std::cout << ",";
                    std::cout << line_in[k];
                }
                std::cout << "]" << std::endl;
            }

            // Convert this slice from power basis to Bernstein basis.
            power_to_bernstein_1d(deg_axis, line_in, line_out);

            if (debug) {
                std::cout << "  line_out=[";
                for (std::size_t k = 0; k < len_axis; ++k) {
                    if (k > 0) std::cout << ",";
                    std::cout << line_out[k];
                }
                std::cout << "]" << std::endl;
            }

            // Scatter converted coefficients back.
            for (std::size_t k = 0; k < len_axis; ++k) {
                multi_index[axis] = static_cast<unsigned int>(k);
                const std::size_t idx = flatten_index(multi_index, strides);
                coeffs[idx] = line_out[k];
            }
        }
    }

    // Debug: print coefficients after conversion
    #if 0
    if (dim == 2 && degrees[0] == 2 && degrees[1] == 1) {
        std::cout << "DEBUG: After power-to-Bernstein conversion for degrees (2,1):" << std::endl;
        for (std::size_t i = 0; i < count; ++i) {
            std::cout << "  coeffs[" << i << "] = " << coeffs[i] << std::endl;
        }
    }
    #endif

    // Now raise degree to at least 1 in each dimension (in Bernstein basis).
    // This ensures proper geometric representation with at least 2 control points per dimension.
    std::vector<unsigned int> adjusted_degrees = degrees;
    bool needs_degree_raising = false;
    for (std::size_t i = 0; i < dim; ++i) {
        if (adjusted_degrees[i] == 0u) {
            adjusted_degrees[i] = 1u;
            needs_degree_raising = true;
        }
    }

    if (needs_degree_raising) {
        // Compute new coefficient count.
        std::size_t new_count = 1u;
        for (std::size_t i = 0; i < dim; ++i) {
            new_count *= static_cast<std::size_t>(adjusted_degrees[i] + 1u);
        }

        std::vector<double> raised_coeffs(new_count, 0.0);

        // Copy coefficients, duplicating along dimensions where degree was raised.
        std::vector<unsigned int> old_multi(dim, 0u);
        std::vector<unsigned int> new_multi(dim, 0u);

        for (std::size_t old_idx = 0; old_idx < count; ++old_idx) {
            // Compute old multi-index.
            std::size_t temp = old_idx;
            for (std::size_t d = dim; d-- > 0;) {
                old_multi[d] = temp % (degrees[d] + 1u);
                temp /= (degrees[d] + 1u);
            }

            // For each dimension where degree was raised, we need to duplicate.
            // Generate all new multi-indices that correspond to this old multi-index.
            std::vector<unsigned int> dup_counts(dim, 1u);
            for (std::size_t d = 0; d < dim; ++d) {
                if (degrees[d] == 0u && adjusted_degrees[d] == 1u) {
                    dup_counts[d] = 2u; // Duplicate this dimension
                }
            }

            // Enumerate all combinations.
            std::vector<unsigned int> dup_idx(dim, 0u);
            bool done = false;
            while (!done) {
                // Compute new multi-index.
                for (std::size_t d = 0; d < dim; ++d) {
                    if (degrees[d] == 0u && adjusted_degrees[d] == 1u) {
                        new_multi[d] = dup_idx[d]; // 0 or 1
                    } else {
                        new_multi[d] = old_multi[d];
                    }
                }

                // Compute new linear index.
                std::size_t new_idx = 0;
                std::size_t stride = 1;
                for (std::size_t d = dim; d-- > 0;) {
                    new_idx += new_multi[d] * stride;
                    stride *= (adjusted_degrees[d] + 1u);
                }

                raised_coeffs[new_idx] = coeffs[old_idx];

                // Increment dup_idx.
                done = true;
                for (std::size_t d = dim; d-- > 0;) {
                    if (dup_idx[d] + 1 < dup_counts[d]) {
                        dup_idx[d]++;
                        for (std::size_t e = d + 1; e < dim; ++e) {
                            dup_idx[e] = 0;
                        }
                        done = false;
                        break;
                    }
                }
            }
        }

        return Polynomial(adjusted_degrees, raised_coeffs);
    }

    return Polynomial(degrees, coeffs);
}

std::size_t Polynomial::dimension() const {
    return dimension_;
}

const std::vector<unsigned int>& Polynomial::degrees() const {
    return degrees_;
}

std::size_t Polynomial::coefficientCount() const {
    std::size_t count = 1u;
    for (std::size_t i = 0; i < degrees_.size(); ++i) {
        count *= static_cast<std::size_t>(degrees_[i] + 1u);
    }
    return count;
}

const std::vector<double>& Polynomial::bernsteinCoefficients() const {
    return bernstein_coeffs_;
}

double Polynomial::evaluate(const std::vector<double>& parameters) const {
    // TODO: Add input validation (parameters.size() == dimension_, etc.).
    return DeCasteljau::evaluateTensorProduct(degrees_, bernstein_coeffs_, parameters);
}

double Polynomial::evaluate(double t) const {
    // Convenience overload for the univariate case.
    std::vector<double> params(1u, t);
    return evaluate(params);
}

Polynomial Polynomial::restrictedToInterval(std::size_t axis, double a, double b) const {
    const std::size_t dim = degrees_.size();
    if (axis >= dim) {
        // Invalid axis: return a copy of the original polynomial.
        return Polynomial(degrees_, bernstein_coeffs_);
    }

    // Clamp a and b to [0,1].
    if (a < 0.0) {
        a = 0.0;
    }
    if (b > 1.0) {
        b = 1.0;
    }

    if (!(a >= 0.0 && b <= 1.0 && a < b)) {
        // Degenerate interval: return a copy.
        return Polynomial(degrees_, bernstein_coeffs_);
    }

    const unsigned int deg_axis = degrees_[axis];
    const std::size_t len_axis = static_cast<std::size_t>(deg_axis + 1u);

    if (len_axis <= 1u) {
        // Constant along this axis.
        return Polynomial(degrees_, bernstein_coeffs_);
    }

    // Precompute strides for tensor layout (last dimension fastest).
    std::vector<std::size_t> strides;
    compute_strides(degrees_, strides);

    std::vector<double> new_coeffs(bernstein_coeffs_.size(), 0.0);

    std::vector<unsigned int> multi_index(dim, 0u);
    std::vector<double> line(len_axis);
    std::vector<double> left;
    std::vector<double> right;

    // Iterate over all 1D slices along the given axis.
    std::fill(multi_index.begin(), multi_index.end(), 0u);
    bool first = true;
    while (first || increment_multi_except_axis(multi_index, degrees_, axis)) {
        first = false;

        // Gather coefficients along the current axis-line.
        for (std::size_t k = 0; k < len_axis; ++k) {
            multi_index[axis] = static_cast<unsigned int>(k);
            const std::size_t idx = flatten_index(multi_index, strides);
            line[k] = bernstein_coeffs_[idx];
        }

        // Restrict this 1D Bernstein polynomial to [a,b].
        std::vector<double> segment = line;

        if (a > 0.0) {
            DeCasteljau::subdivide1D(segment, a, left, right);
            segment = right; // [a,1]
        }

        const double denom = 1.0 - a;
        const double t_rel = (denom > 0.0) ? (b - a) / denom : 0.0;
        DeCasteljau::subdivide1D(segment, t_rel, left, right);

        const std::vector<double>& ab_coeffs = left; // represents [a,b]

        // Scatter the restricted coefficients back into the tensor.
        for (std::size_t k = 0; k < len_axis; ++k) {
            multi_index[axis] = static_cast<unsigned int>(k);
            const std::size_t idx = flatten_index(multi_index, strides);
            new_coeffs[idx] = ab_coeffs[k];
        }
    }

    return Polynomial(degrees_, new_coeffs);
}

std::size_t Polynomial::flattenIndex(const std::vector<unsigned int>& multi_index) const {
    std::size_t idx = 0u;
    std::size_t stride = 1u;
    const std::size_t dim = degrees_.size();

    // Last dimension varies fastest.
    for (std::size_t d = dim; d-- > 0;) {
        idx += static_cast<std::size_t>(multi_index[d]) * stride;
        stride *= static_cast<std::size_t>(degrees_[d] + 1u);
    }

    return idx;
}

void Polynomial::graphControlPoints(std::vector<double>& control_points) const {
    const std::size_t dim = dimension_;
    const std::size_t coeff_count = coefficientCount();

    const std::size_t stride = dim + 1u;
    control_points.assign(coeff_count * stride, 0.0);

    if (coeff_count == 0u) {
        return;
    }

    std::vector<unsigned int> multi_index(dim, 0u);
    std::size_t idx = 0u;

    while (true) {
        const std::size_t base = idx * stride;

        // First dim coordinates: normalized parameter position.
        for (std::size_t j = 0; j < dim; ++j) {
            const unsigned int deg_j = degrees_[j];
            double coord = 0.0;
            if (deg_j > 0u) {
                coord = static_cast<double>(multi_index[j]) /
                        static_cast<double>(deg_j);
            }
            control_points[base + j] = coord;
        }

        // Last coordinate: function value (Bernstein coefficient).
        control_points[base + dim] = bernstein_coeffs_[idx];

        if (idx + 1u >= coeff_count) {
            break;
        }

        ++idx;

        // Increment multi-index with last dimension fastest.
        if (dim > 0u) {
            for (std::size_t d = dim; d-- > 0;) {
                if (multi_index[d] < degrees_[d]) {
                    ++multi_index[d];
                    for (std::size_t e = d + 1; e < dim; ++e) {
                        multi_index[e] = 0u;
                    }
                    break;
                }
            }
        }
    }
}


} // namespace polynomial_solver
